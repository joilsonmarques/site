"""Direct the client to resolve this field locally, either from the cache or local resolvers."""
directive @client(
  """
  When true, the client will never use the cache for this value. See
  https://www.apollographql.com/docs/react/essentials/local-state/#forcing-resolvers-with-clientalways-true
  """
  always: Boolean
) on FIELD | FRAGMENT_DEFINITION | INLINE_FRAGMENT

"""
Export this locally resolved field as a variable to be used in the remainder of this query. See
https://www.apollographql.com/docs/react/essentials/local-state/#using-client-fields-as-variables
"""
directive @export(
  """The variable name to export this field as."""
  as: String!
) on FIELD

"""
Specify a custom store key for this result. See
https://www.apollographql.com/docs/react/advanced/caching/#the-connection-directive
"""
directive @connection(
  """Specify the store key."""
  key: String!
  """An array of query argument names to include in the generated custom store key."""
  filter: [String!]
) on FIELD

input FileInfoInput {
  name: String
  alternativeText: String
  caption: String
}

type UsersPermissionsMe {
  id: ID!
  username: String!
  email: String!
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsMeRole
}

type UsersPermissionsMeRole {
  id: ID!
  name: String!
  description: String
  type: String
}

input UsersPermissionsRegisterInput {
  username: String!
  email: String!
  password: String!
}

input UsersPermissionsLoginInput {
  identifier: String!
  password: String!
  provider: String = "local"
}

type UsersPermissionsLoginPayload {
  jwt: String
  user: UsersPermissionsMe!
}

type UserPermissionsPasswordPayload {
  ok: Boolean!
}

type Author {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String!
  bio: String
  slug: String!
  published_at: DateTime
  episodes(sort: String, limit: Int, start: Int, where: JSON): [Episode!]!
  posts(sort: String, limit: Int, start: Int, where: JSON): [Posts!]!
  avatar(sort: String, limit: Int, start: Int, where: JSON): [UploadFile!]!
}

type AuthorConnection {
  values: [Author]
  groupBy: AuthorGroupBy
  aggregate: AuthorAggregator
}

type AuthorAggregator {
  count: Int
  totalCount: Int
}

type AuthorGroupBy {
  id: [AuthorConnectionId]
  created_at: [AuthorConnectionCreated_at]
  updated_at: [AuthorConnectionUpdated_at]
  name: [AuthorConnectionName]
  bio: [AuthorConnectionBio]
  slug: [AuthorConnectionSlug]
  published_at: [AuthorConnectionPublished_at]
}

type AuthorConnectionId {
  key: ID
  connection: AuthorConnection
}

type AuthorConnectionCreated_at {
  key: DateTime
  connection: AuthorConnection
}

type AuthorConnectionUpdated_at {
  key: DateTime
  connection: AuthorConnection
}

type AuthorConnectionName {
  key: String
  connection: AuthorConnection
}

type AuthorConnectionBio {
  key: String
  connection: AuthorConnection
}

type AuthorConnectionSlug {
  key: String
  connection: AuthorConnection
}

type AuthorConnectionPublished_at {
  key: DateTime
  connection: AuthorConnection
}

input AuthorInput {
  name: String!
  bio: String
  slug: String!
  episodes: [ID]
  posts: [ID]
  avatar: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editAuthorInput {
  name: String
  bio: String
  slug: String
  episodes: [ID]
  posts: [ID]
  avatar: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createAuthorInput {
  data: AuthorInput
}

type createAuthorPayload {
  author: Author
}

input updateAuthorInput {
  where: InputID
  data: editAuthorInput
}

type updateAuthorPayload {
  author: Author
}

input deleteAuthorInput {
  where: InputID
}

type deleteAuthorPayload {
  author: Author
}

type BarraLateral {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  logo: UploadFile
  tituloSite: String!
  menu: [ComponentFragmentListaDeLinks]
}

input BarraLateralInput {
  logo: ID
  tituloSite: String!
  menu: [ComponentFragmentListaDeLinkInput!]
  created_by: ID
  updated_by: ID
}

input editBarraLateralInput {
  logo: ID
  tituloSite: String
  menu: [editComponentFragmentListaDeLinkInput]
  created_by: ID
  updated_by: ID
}

input updateBarraLateralInput {
  data: editBarraLateralInput
}

type updateBarraLateralPayload {
  barraLateral: BarraLateral
}

type deleteBarraLateralPayload {
  barraLateral: BarraLateral
}

type Category {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String!
  slug: String!
  episodes(sort: String, limit: Int, start: Int, where: JSON): [Episode!]!
  podcasts(sort: String, limit: Int, start: Int, where: JSON): [Podcasts!]!
  pagina_genericas(sort: String, limit: Int, start: Int, where: JSON): [Posts!]!
}

type CategoryConnection {
  values: [Category]
  groupBy: CategoryGroupBy
  aggregate: CategoryAggregator
}

type CategoryAggregator {
  count: Int
  totalCount: Int
}

type CategoryGroupBy {
  id: [CategoryConnectionId]
  created_at: [CategoryConnectionCreated_at]
  updated_at: [CategoryConnectionUpdated_at]
  name: [CategoryConnectionName]
  slug: [CategoryConnectionSlug]
}

type CategoryConnectionId {
  key: ID
  connection: CategoryConnection
}

type CategoryConnectionCreated_at {
  key: DateTime
  connection: CategoryConnection
}

type CategoryConnectionUpdated_at {
  key: DateTime
  connection: CategoryConnection
}

type CategoryConnectionName {
  key: String
  connection: CategoryConnection
}

type CategoryConnectionSlug {
  key: String
  connection: CategoryConnection
}

input CategoryInput {
  name: String!
  slug: String!
  episodes: [ID]
  podcasts: [ID]
  pagina_genericas: [ID]
  created_by: ID
  updated_by: ID
}

input editCategoryInput {
  name: String
  slug: String
  episodes: [ID]
  podcasts: [ID]
  pagina_genericas: [ID]
  created_by: ID
  updated_by: ID
}

input createCategoryInput {
  data: CategoryInput
}

type createCategoryPayload {
  category: Category
}

input updateCategoryInput {
  where: InputID
  data: editCategoryInput
}

type updateCategoryPayload {
  category: Category
}

input deleteCategoryInput {
  where: InputID
}

type deleteCategoryPayload {
  category: Category
}

type Episode {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  title: String!
  slug: String
  subTitle: String
  releaseDate: Date!
  extraContent: String
  cover: UploadFile
  podcast: Podcasts
  embed: String
  episodeNumber: Int!
  season: String
  inputTag: String
  published_at: DateTime
  categories(sort: String, limit: Int, start: Int, where: JSON): [Category!]!
  authors(sort: String, limit: Int, start: Int, where: JSON): [Author!]!
}

type EpisodeConnection {
  values: [Episode]
  groupBy: EpisodeGroupBy
  aggregate: EpisodeAggregator
}

type EpisodeAggregator {
  count: Int
  totalCount: Int
  sum: EpisodeAggregatorSum
  avg: EpisodeAggregatorAvg
  min: EpisodeAggregatorMin
  max: EpisodeAggregatorMax
}

type EpisodeAggregatorSum {
  episodeNumber: Float
}

type EpisodeAggregatorAvg {
  episodeNumber: Float
}

type EpisodeAggregatorMin {
  episodeNumber: Float
}

type EpisodeAggregatorMax {
  episodeNumber: Float
}

type EpisodeGroupBy {
  id: [EpisodeConnectionId]
  created_at: [EpisodeConnectionCreated_at]
  updated_at: [EpisodeConnectionUpdated_at]
  title: [EpisodeConnectionTitle]
  slug: [EpisodeConnectionSlug]
  subTitle: [EpisodeConnectionSubTitle]
  releaseDate: [EpisodeConnectionReleaseDate]
  extraContent: [EpisodeConnectionExtraContent]
  cover: [EpisodeConnectionCover]
  podcast: [EpisodeConnectionPodcast]
  embed: [EpisodeConnectionEmbed]
  episodeNumber: [EpisodeConnectionEpisodeNumber]
  season: [EpisodeConnectionSeason]
  inputTag: [EpisodeConnectionInputTag]
  published_at: [EpisodeConnectionPublished_at]
}

type EpisodeConnectionId {
  key: ID
  connection: EpisodeConnection
}

type EpisodeConnectionCreated_at {
  key: DateTime
  connection: EpisodeConnection
}

type EpisodeConnectionUpdated_at {
  key: DateTime
  connection: EpisodeConnection
}

type EpisodeConnectionTitle {
  key: String
  connection: EpisodeConnection
}

type EpisodeConnectionSlug {
  key: String
  connection: EpisodeConnection
}

type EpisodeConnectionSubTitle {
  key: String
  connection: EpisodeConnection
}

type EpisodeConnectionReleaseDate {
  key: ID
  connection: EpisodeConnection
}

type EpisodeConnectionExtraContent {
  key: String
  connection: EpisodeConnection
}

type EpisodeConnectionCover {
  key: ID
  connection: EpisodeConnection
}

type EpisodeConnectionPodcast {
  key: ID
  connection: EpisodeConnection
}

type EpisodeConnectionEmbed {
  key: String
  connection: EpisodeConnection
}

type EpisodeConnectionEpisodeNumber {
  key: Int
  connection: EpisodeConnection
}

type EpisodeConnectionSeason {
  key: String
  connection: EpisodeConnection
}

type EpisodeConnectionInputTag {
  key: String
  connection: EpisodeConnection
}

type EpisodeConnectionPublished_at {
  key: DateTime
  connection: EpisodeConnection
}

input EpisodeInput {
  title: String!
  slug: String
  subTitle: String
  releaseDate: Date!
  extraContent: String
  cover: ID
  categories: [ID]
  authors: [ID]
  podcast: ID
  embed: String
  episodeNumber: Int!
  season: String
  inputTag: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editEpisodeInput {
  title: String
  slug: String
  subTitle: String
  releaseDate: Date
  extraContent: String
  cover: ID
  categories: [ID]
  authors: [ID]
  podcast: ID
  embed: String
  episodeNumber: Int
  season: String
  inputTag: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createEpisodeInput {
  data: EpisodeInput
}

type createEpisodePayload {
  episode: Episode
}

input updateEpisodeInput {
  where: InputID
  data: editEpisodeInput
}

type updateEpisodePayload {
  episode: Episode
}

input deleteEpisodeInput {
  where: InputID
}

type deleteEpisodePayload {
  episode: Episode
}

union HomeSectionDynamicZone = ComponentSiteIntro | ComponentSectionFeaturedPodcast | ComponentSectionSelectedEpisodes | ComponentSectionExtra | ComponentSectionCallToAction

"""Input type for dynamic zone Section of Home"""
scalar HomeSectionDynamicZoneInput

type Home {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  Section: [HomeSectionDynamicZone]!
  published_at: DateTime
}

input HomeInput {
  Section: [HomeSectionDynamicZoneInput!]!
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editHomeInput {
  Section: [HomeSectionDynamicZoneInput!]!
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input updateHomeInput {
  data: editHomeInput
}

type updateHomePayload {
  home: Home
}

type deleteHomePayload {
  home: Home
}

union PagesSectionDynamicZone = ComponentFragmentIntegrante | ComponentFragmentSectionDivider | ComponentFragmentEmbed | ComponentSectionCallToAction | ComponentSectionExtra

"""Input type for dynamic zone section of Pages"""
scalar PagesSectionDynamicZoneInput

type Pages {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  title: String!
  description: String
  Slug: String!
  section: [PagesSectionDynamicZone]
  published_at: DateTime
}

type PagesConnection {
  values: [Pages]
  groupBy: PagesGroupBy
  aggregate: PagesAggregator
}

type PagesAggregator {
  count: Int
  totalCount: Int
}

type PagesGroupBy {
  id: [PagesConnectionId]
  created_at: [PagesConnectionCreated_at]
  updated_at: [PagesConnectionUpdated_at]
  title: [PagesConnectionTitle]
  description: [PagesConnectionDescription]
  Slug: [PagesConnectionSlug]
  published_at: [PagesConnectionPublished_at]
}

type PagesConnectionId {
  key: ID
  connection: PagesConnection
}

type PagesConnectionCreated_at {
  key: DateTime
  connection: PagesConnection
}

type PagesConnectionUpdated_at {
  key: DateTime
  connection: PagesConnection
}

type PagesConnectionTitle {
  key: String
  connection: PagesConnection
}

type PagesConnectionDescription {
  key: String
  connection: PagesConnection
}

type PagesConnectionSlug {
  key: String
  connection: PagesConnection
}

type PagesConnectionPublished_at {
  key: DateTime
  connection: PagesConnection
}

input PageInput {
  title: String!
  description: String
  Slug: String!
  section: [PagesSectionDynamicZoneInput!]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editPageInput {
  title: String
  description: String
  Slug: String
  section: [PagesSectionDynamicZoneInput!]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createPageInput {
  data: PageInput
}

type createPagePayload {
  page: Pages
}

input updatePageInput {
  where: InputID
  data: editPageInput
}

type updatePagePayload {
  page: Pages
}

input deletePageInput {
  where: InputID
}

type deletePagePayload {
  page: Pages
}

type Podcasts {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  title: String!
  slug: String!
  cover: UploadFile
  description: String
  subtitle: String
  producer: String!
  published_at: DateTime
  episodes(sort: String, limit: Int, start: Int, where: JSON): [Episode!]!
  categories(sort: String, limit: Int, start: Int, where: JSON): [Category!]!
}

type PodcastsConnection {
  values: [Podcasts]
  groupBy: PodcastsGroupBy
  aggregate: PodcastsAggregator
}

type PodcastsAggregator {
  count: Int
  totalCount: Int
}

type PodcastsGroupBy {
  id: [PodcastsConnectionId]
  created_at: [PodcastsConnectionCreated_at]
  updated_at: [PodcastsConnectionUpdated_at]
  title: [PodcastsConnectionTitle]
  slug: [PodcastsConnectionSlug]
  cover: [PodcastsConnectionCover]
  description: [PodcastsConnectionDescription]
  subtitle: [PodcastsConnectionSubtitle]
  producer: [PodcastsConnectionProducer]
  published_at: [PodcastsConnectionPublished_at]
}

type PodcastsConnectionId {
  key: ID
  connection: PodcastsConnection
}

type PodcastsConnectionCreated_at {
  key: DateTime
  connection: PodcastsConnection
}

type PodcastsConnectionUpdated_at {
  key: DateTime
  connection: PodcastsConnection
}

type PodcastsConnectionTitle {
  key: String
  connection: PodcastsConnection
}

type PodcastsConnectionSlug {
  key: String
  connection: PodcastsConnection
}

type PodcastsConnectionCover {
  key: ID
  connection: PodcastsConnection
}

type PodcastsConnectionDescription {
  key: String
  connection: PodcastsConnection
}

type PodcastsConnectionSubtitle {
  key: String
  connection: PodcastsConnection
}

type PodcastsConnectionProducer {
  key: String
  connection: PodcastsConnection
}

type PodcastsConnectionPublished_at {
  key: DateTime
  connection: PodcastsConnection
}

input PodcastInput {
  title: String!
  slug: String!
  episodes: [ID]
  cover: ID
  description: String
  categories: [ID]
  subtitle: String
  producer: String!
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editPodcastInput {
  title: String
  slug: String
  episodes: [ID]
  cover: ID
  description: String
  categories: [ID]
  subtitle: String
  producer: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createPodcastInput {
  data: PodcastInput
}

type createPodcastPayload {
  podcast: Podcasts
}

input updatePodcastInput {
  where: InputID
  data: editPodcastInput
}

type updatePodcastPayload {
  podcast: Podcasts
}

input deletePodcastInput {
  where: InputID
}

type deletePodcastPayload {
  podcast: Podcasts
}

type Posts {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  cover: UploadFile
  title: String!
  slug: String!
  summary: String!
  content: String
  author: Author
  tags: [ComponentFragmentTags]
  published_at: DateTime
  categorias(sort: String, limit: Int, start: Int, where: JSON): [Category!]!
}

type PostsConnection {
  values: [Posts]
  groupBy: PostsGroupBy
  aggregate: PostsAggregator
}

type PostsAggregator {
  count: Int
  totalCount: Int
}

type PostsGroupBy {
  id: [PostsConnectionId]
  created_at: [PostsConnectionCreated_at]
  updated_at: [PostsConnectionUpdated_at]
  cover: [PostsConnectionCover]
  title: [PostsConnectionTitle]
  slug: [PostsConnectionSlug]
  summary: [PostsConnectionSummary]
  content: [PostsConnectionContent]
  author: [PostsConnectionAuthor]
  published_at: [PostsConnectionPublished_at]
}

type PostsConnectionId {
  key: ID
  connection: PostsConnection
}

type PostsConnectionCreated_at {
  key: DateTime
  connection: PostsConnection
}

type PostsConnectionUpdated_at {
  key: DateTime
  connection: PostsConnection
}

type PostsConnectionCover {
  key: ID
  connection: PostsConnection
}

type PostsConnectionTitle {
  key: String
  connection: PostsConnection
}

type PostsConnectionSlug {
  key: String
  connection: PostsConnection
}

type PostsConnectionSummary {
  key: String
  connection: PostsConnection
}

type PostsConnectionContent {
  key: String
  connection: PostsConnection
}

type PostsConnectionAuthor {
  key: ID
  connection: PostsConnection
}

type PostsConnectionPublished_at {
  key: DateTime
  connection: PostsConnection
}

input PostInput {
  cover: ID
  title: String!
  slug: String!
  summary: String!
  content: String
  author: ID
  tags: [ComponentFragmentTagInput]
  categorias: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editPostInput {
  cover: ID
  title: String
  slug: String
  summary: String
  content: String
  author: ID
  tags: [editComponentFragmentTagInput]
  categorias: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createPostInput {
  data: PostInput
}

type createPostPayload {
  post: Posts
}

input updatePostInput {
  where: InputID
  data: editPostInput
}

type updatePostPayload {
  post: Posts
}

input deletePostInput {
  where: InputID
}

type deletePostPayload {
  post: Posts
}

type Rodape {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  contacts: ComponentSiteContato
  links: [ComponentFragmentListaDeLinks]
}

input RodapeInput {
  contacts: ComponentSiteContatoInput
  links: [ComponentFragmentListaDeLinkInput]
  created_by: ID
  updated_by: ID
}

input editRodapeInput {
  contacts: editComponentSiteContatoInput
  links: [editComponentFragmentListaDeLinkInput]
  created_by: ID
  updated_by: ID
}

input updateRodapeInput {
  data: editRodapeInput
}

type updateRodapePayload {
  rodape: Rodape
}

type deleteRodapePayload {
  rodape: Rodape
}

type Sobre {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  Title: String!
  Embed: String
  Summary: String!
  Members: [ComponentFragmentIntegrante]
  published_at: DateTime
}

input SobreInput {
  Title: String
  Embed: String
  Summary: String!
  Members: [ComponentFragmentIntegranteInput]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editSobreInput {
  Title: String
  Embed: String
  Summary: String
  Members: [editComponentFragmentIntegranteInput]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input updateSobreInput {
  data: editSobreInput
}

type updateSobrePayload {
  sobre: Sobre
}

type deleteSobrePayload {
  sobre: Sobre
}

type Tags {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  nome: String
  slug: String
  published_at: DateTime
}

type TagsConnection {
  values: [Tags]
  groupBy: TagsGroupBy
  aggregate: TagsAggregator
}

type TagsAggregator {
  count: Int
  totalCount: Int
}

type TagsGroupBy {
  id: [TagsConnectionId]
  created_at: [TagsConnectionCreated_at]
  updated_at: [TagsConnectionUpdated_at]
  nome: [TagsConnectionNome]
  slug: [TagsConnectionSlug]
  published_at: [TagsConnectionPublished_at]
}

type TagsConnectionId {
  key: ID
  connection: TagsConnection
}

type TagsConnectionCreated_at {
  key: DateTime
  connection: TagsConnection
}

type TagsConnectionUpdated_at {
  key: DateTime
  connection: TagsConnection
}

type TagsConnectionNome {
  key: String
  connection: TagsConnection
}

type TagsConnectionSlug {
  key: String
  connection: TagsConnection
}

type TagsConnectionPublished_at {
  key: DateTime
  connection: TagsConnection
}

input TagInput {
  nome: String
  slug: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editTagInput {
  nome: String
  slug: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createTagInput {
  data: TagInput
}

type createTagPayload {
  tag: Tags
}

input updateTagInput {
  where: InputID
  data: editTagInput
}

type updateTagPayload {
  tag: Tags
}

input deleteTagInput {
  where: InputID
}

type deleteTagPayload {
  tag: Tags
}

type Test {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  title: String
  slug: String
  email: String
  published_at: DateTime
}

type TestConnection {
  values: [Test]
  groupBy: TestGroupBy
  aggregate: TestAggregator
}

type TestAggregator {
  count: Int
  totalCount: Int
}

type TestGroupBy {
  id: [TestConnectionId]
  created_at: [TestConnectionCreated_at]
  updated_at: [TestConnectionUpdated_at]
  title: [TestConnectionTitle]
  slug: [TestConnectionSlug]
  email: [TestConnectionEmail]
  published_at: [TestConnectionPublished_at]
}

type TestConnectionId {
  key: ID
  connection: TestConnection
}

type TestConnectionCreated_at {
  key: DateTime
  connection: TestConnection
}

type TestConnectionUpdated_at {
  key: DateTime
  connection: TestConnection
}

type TestConnectionTitle {
  key: String
  connection: TestConnection
}

type TestConnectionSlug {
  key: String
  connection: TestConnection
}

type TestConnectionEmail {
  key: String
  connection: TestConnection
}

type TestConnectionPublished_at {
  key: DateTime
  connection: TestConnection
}

input TestInput {
  title: String
  slug: String
  email: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editTestInput {
  title: String
  slug: String
  email: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createTestInput {
  data: TestInput
}

type createTestPayload {
  test: Test
}

input updateTestInput {
  where: InputID
  data: editTestInput
}

type updateTestPayload {
  test: Test
}

input deleteTestInput {
  where: InputID
}

type deleteTestPayload {
  test: Test
}

type I18NLocale {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String
  code: String
}

input LocaleInput {
  name: String
  code: String
  created_by: ID
  updated_by: ID
}

input editLocaleInput {
  name: String
  code: String
  created_by: ID
  updated_by: ID
}

type UploadFile {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String!
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String!
  ext: String
  mime: String!
  size: Float!
  url: String!
  previewUrl: String
  provider: String!
  provider_metadata: JSON
  related(sort: String, limit: Int, start: Int, where: JSON): [Morph!]!
}

type UploadFileConnection {
  values: [UploadFile]
  groupBy: UploadFileGroupBy
  aggregate: UploadFileAggregator
}

type UploadFileAggregator {
  count: Int
  totalCount: Int
  sum: UploadFileAggregatorSum
  avg: UploadFileAggregatorAvg
  min: UploadFileAggregatorMin
  max: UploadFileAggregatorMax
}

type UploadFileAggregatorSum {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorAvg {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorMin {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorMax {
  width: Float
  height: Float
  size: Float
}

type UploadFileGroupBy {
  id: [UploadFileConnectionId]
  created_at: [UploadFileConnectionCreated_at]
  updated_at: [UploadFileConnectionUpdated_at]
  name: [UploadFileConnectionName]
  alternativeText: [UploadFileConnectionAlternativeText]
  caption: [UploadFileConnectionCaption]
  width: [UploadFileConnectionWidth]
  height: [UploadFileConnectionHeight]
  formats: [UploadFileConnectionFormats]
  hash: [UploadFileConnectionHash]
  ext: [UploadFileConnectionExt]
  mime: [UploadFileConnectionMime]
  size: [UploadFileConnectionSize]
  url: [UploadFileConnectionUrl]
  previewUrl: [UploadFileConnectionPreviewUrl]
  provider: [UploadFileConnectionProvider]
  provider_metadata: [UploadFileConnectionProvider_metadata]
}

type UploadFileConnectionId {
  key: ID
  connection: UploadFileConnection
}

type UploadFileConnectionCreated_at {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionUpdated_at {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionName {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionAlternativeText {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionCaption {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionWidth {
  key: Int
  connection: UploadFileConnection
}

type UploadFileConnectionHeight {
  key: Int
  connection: UploadFileConnection
}

type UploadFileConnectionFormats {
  key: JSON
  connection: UploadFileConnection
}

type UploadFileConnectionHash {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionExt {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionMime {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionSize {
  key: Float
  connection: UploadFileConnection
}

type UploadFileConnectionUrl {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionPreviewUrl {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionProvider {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionProvider_metadata {
  key: JSON
  connection: UploadFileConnection
}

input FileInput {
  name: String!
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String!
  ext: String
  mime: String!
  size: Float!
  url: String!
  previewUrl: String
  provider: String!
  provider_metadata: JSON
  related: [ID]
  created_by: ID
  updated_by: ID
}

input editFileInput {
  name: String
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String
  ext: String
  mime: String
  size: Float
  url: String
  previewUrl: String
  provider: String
  provider_metadata: JSON
  related: [ID]
  created_by: ID
  updated_by: ID
}

input deleteFileInput {
  where: InputID
}

type deleteFilePayload {
  file: UploadFile
}

type UsersPermissionsPermission {
  id: ID!
  type: String!
  controller: String!
  action: String!
  enabled: Boolean!
  policy: String
  role: UsersPermissionsRole
}

type UsersPermissionsRole {
  id: ID!
  name: String!
  description: String
  type: String
  permissions(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsPermission!]!
  users(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsUser!]!
}

type UsersPermissionsRoleConnection {
  values: [UsersPermissionsRole]
  groupBy: UsersPermissionsRoleGroupBy
  aggregate: UsersPermissionsRoleAggregator
}

type UsersPermissionsRoleAggregator {
  count: Int
  totalCount: Int
}

type UsersPermissionsRoleGroupBy {
  id: [UsersPermissionsRoleConnectionId]
  name: [UsersPermissionsRoleConnectionName]
  description: [UsersPermissionsRoleConnectionDescription]
  type: [UsersPermissionsRoleConnectionType]
}

type UsersPermissionsRoleConnectionId {
  key: ID
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionName {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionDescription {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionType {
  key: String
  connection: UsersPermissionsRoleConnection
}

input RoleInput {
  name: String!
  description: String
  type: String
  permissions: [ID]
  users: [ID]
  created_by: ID
  updated_by: ID
}

input editRoleInput {
  name: String
  description: String
  type: String
  permissions: [ID]
  users: [ID]
  created_by: ID
  updated_by: ID
}

input createRoleInput {
  data: RoleInput
}

type createRolePayload {
  role: UsersPermissionsRole
}

input updateRoleInput {
  where: InputID
  data: editRoleInput
}

type updateRolePayload {
  role: UsersPermissionsRole
}

input deleteRoleInput {
  where: InputID
}

type deleteRolePayload {
  role: UsersPermissionsRole
}

type UsersPermissionsUser {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  username: String!
  email: String!
  provider: String
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsRole
}

type UsersPermissionsUserConnection {
  values: [UsersPermissionsUser]
  groupBy: UsersPermissionsUserGroupBy
  aggregate: UsersPermissionsUserAggregator
}

type UsersPermissionsUserAggregator {
  count: Int
  totalCount: Int
}

type UsersPermissionsUserGroupBy {
  id: [UsersPermissionsUserConnectionId]
  created_at: [UsersPermissionsUserConnectionCreated_at]
  updated_at: [UsersPermissionsUserConnectionUpdated_at]
  username: [UsersPermissionsUserConnectionUsername]
  email: [UsersPermissionsUserConnectionEmail]
  provider: [UsersPermissionsUserConnectionProvider]
  confirmed: [UsersPermissionsUserConnectionConfirmed]
  blocked: [UsersPermissionsUserConnectionBlocked]
  role: [UsersPermissionsUserConnectionRole]
}

type UsersPermissionsUserConnectionId {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionCreated_at {
  key: DateTime
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUpdated_at {
  key: DateTime
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUsername {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionEmail {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionProvider {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionConfirmed {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionBlocked {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionRole {
  key: ID
  connection: UsersPermissionsUserConnection
}

input UserInput {
  username: String!
  email: String!
  provider: String
  password: String
  resetPasswordToken: String
  confirmationToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
  created_by: ID
  updated_by: ID
}

input editUserInput {
  username: String
  email: String
  provider: String
  password: String
  resetPasswordToken: String
  confirmationToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
  created_by: ID
  updated_by: ID
}

input createUserInput {
  data: UserInput
}

type createUserPayload {
  user: UsersPermissionsUser
}

input updateUserInput {
  where: InputID
  data: editUserInput
}

type updateUserPayload {
  user: UsersPermissionsUser
}

input deleteUserInput {
  where: InputID
}

type deleteUserPayload {
  user: UsersPermissionsUser
}

type ComponentFragmentEmbed {
  id: ID!
  embed: String!
}

input ComponentFragmentEmbedInput {
  embed: String!
}

input editComponentFragmentEmbedInput {
  id: ID
  embed: String
}

type ComponentFragmentHyperlink {
  id: ID!
  url: String!
  isExternal: Boolean!
}

input ComponentFragmentHyperlinkInput {
  url: String!
  isExternal: Boolean
}

input editComponentFragmentHyperlinkInput {
  id: ID
  url: String
  isExternal: Boolean
}

type ComponentFragmentIntegrante {
  id: ID!
  avatar: UploadFile
  name: String!
  bio: String!
  links: [ComponentFragmentLinks]
}

input ComponentFragmentIntegranteInput {
  avatar: ID
  name: String!
  bio: String!
  links: [ComponentFragmentLinkInput]
}

input editComponentFragmentIntegranteInput {
  id: ID
  avatar: ID
  name: String
  bio: String
  links: [editComponentFragmentLinkInput]
}

enum ENUM_COMPONENTFRAGMENTLINKS_NETWORK {
  Clubhouse
  Ello
  Facebook
  Instagram
  Linkedin
  Medium
  Reddit
  Snapchat
  Soundcloud
  Tiktok
  YouTube
}

type ComponentFragmentLinks {
  id: ID!
  network: ENUM_COMPONENTFRAGMENTLINKS_NETWORK
  url: String!
}

input ComponentFragmentLinkInput {
  network: ENUM_COMPONENTFRAGMENTLINKS_NETWORK
  url: String!
}

input editComponentFragmentLinkInput {
  id: ID
  network: ENUM_COMPONENTFRAGMENTLINKS_NETWORK
  url: String
}

enum ENUM_COMPONENTFRAGMENTLISTADELINKS_TYPE {
  externo
  interno
  generico
}

type ComponentFragmentListaDeLinks {
  id: ID!
  label: String!
  url: String
  pagina_generica: Posts
  type: ENUM_COMPONENTFRAGMENTLISTADELINKS_TYPE!
}

input ComponentFragmentListaDeLinkInput {
  label: String!
  url: String
  pagina_generica: ID
  type: ENUM_COMPONENTFRAGMENTLISTADELINKS_TYPE!
}

input editComponentFragmentListaDeLinkInput {
  id: ID
  label: String
  url: String
  pagina_generica: ID
  type: ENUM_COMPONENTFRAGMENTLISTADELINKS_TYPE
}

type ComponentFragmentSectionDivider {
  id: ID!
  sectionTitle: String!
  description: String
  cover: UploadFile
}

input ComponentFragmentSectionDividerInput {
  sectionTitle: String!
  description: String
  cover: ID
}

input editComponentFragmentSectionDividerInput {
  id: ID
  sectionTitle: String
  description: String
  cover: ID
}

type ComponentFragmentTags {
  id: ID!
  name: String!
}

input ComponentFragmentTagInput {
  name: String!
}

input editComponentFragmentTagInput {
  id: ID
  name: String
}

type ComponentSectionCallToAction {
  id: ID!
  title: String!
  listLinks: [ComponentFragmentListaDeLinks]
}

input ComponentSectionCallToActionInput {
  title: String
  listLinks: [ComponentFragmentListaDeLinkInput]
}

input editComponentSectionCallToActionInput {
  id: ID
  title: String
  listLinks: [editComponentFragmentListaDeLinkInput]
}

type ComponentSectionExtra {
  id: ID!
  title: String!
  subtitle: String
  primaryInfo: String
  secondaryInfo: String
  embed: String!
  cover: UploadFile
  link: ComponentFragmentHyperlink
}

input ComponentSectionExtraInput {
  title: String!
  subtitle: String
  primaryInfo: String
  secondaryInfo: String
  embed: String!
  cover: ID
  link: ComponentFragmentHyperlinkInput!
}

input editComponentSectionExtraInput {
  id: ID
  title: String
  subtitle: String
  primaryInfo: String
  secondaryInfo: String
  embed: String
  cover: ID
  link: editComponentFragmentHyperlinkInput
}

type ComponentSectionFeaturedPodcast {
  id: ID!
  podcast: Podcasts
  showLastEpisode: Boolean
  background: UploadFile
  sectionTitle: String
  description: String!
}

input ComponentSectionFeaturedPodcastInput {
  podcast: ID
  showLastEpisode: Boolean
  background: ID
  sectionTitle: String
  description: String!
}

input editComponentSectionFeaturedPodcastInput {
  id: ID
  podcast: ID
  showLastEpisode: Boolean
  background: ID
  sectionTitle: String
  description: String
}

type ComponentSectionSelectedEpisodes {
  id: ID!
  sectionTitle: String
  episodes(sort: String, limit: Int, start: Int, where: JSON): [Episode!]!
}

input ComponentSectionSelectedEpisodeInput {
  episodes: [ID]
  sectionTitle: String
}

input editComponentSectionSelectedEpisodeInput {
  id: ID
  episodes: [ID]
  sectionTitle: String
}

type ComponentSiteBarraLateral {
  id: ID!
  logo: UploadFile
  siteTitle: String!
}

input ComponentSiteBarraLateralInput {
  logo: ID
  siteTitle: String
}

input editComponentSiteBarraLateralInput {
  id: ID
  logo: ID
  siteTitle: String
}

type ComponentSiteContato {
  id: ID!
  title: String!
  phoneNumber: String
  email: String
  redes: ComponentFragmentLinks
}

input ComponentSiteContatoInput {
  title: String
  phoneNumber: String
  email: String
  redes: ComponentFragmentLinkInput
}

input editComponentSiteContatoInput {
  id: ID
  title: String
  phoneNumber: String
  email: String
  redes: editComponentFragmentLinkInput
}

type ComponentSiteIntro {
  id: ID!
  call: String!
  hasDetail: Boolean!
  description: String
  embed: String
}

input ComponentSiteIntroInput {
  call: String!
  hasDetail: Boolean
  description: String
  embed: String
}

input editComponentSiteIntroInput {
  id: ID
  call: String
  hasDetail: Boolean
  description: String
  embed: String
}

union Morph = UsersPermissionsMe | UsersPermissionsMeRole | UsersPermissionsLoginPayload | UserPermissionsPasswordPayload | Author | AuthorConnection | AuthorAggregator | AuthorGroupBy | AuthorConnectionId | AuthorConnectionCreated_at | AuthorConnectionUpdated_at | AuthorConnectionName | AuthorConnectionBio | AuthorConnectionSlug | AuthorConnectionPublished_at | createAuthorPayload | updateAuthorPayload | deleteAuthorPayload | BarraLateral | updateBarraLateralPayload | deleteBarraLateralPayload | Category | CategoryConnection | CategoryAggregator | CategoryGroupBy | CategoryConnectionId | CategoryConnectionCreated_at | CategoryConnectionUpdated_at | CategoryConnectionName | CategoryConnectionSlug | createCategoryPayload | updateCategoryPayload | deleteCategoryPayload | Episode | EpisodeConnection | EpisodeAggregator | EpisodeAggregatorSum | EpisodeAggregatorAvg | EpisodeAggregatorMin | EpisodeAggregatorMax | EpisodeGroupBy | EpisodeConnectionId | EpisodeConnectionCreated_at | EpisodeConnectionUpdated_at | EpisodeConnectionTitle | EpisodeConnectionSlug | EpisodeConnectionSubTitle | EpisodeConnectionReleaseDate | EpisodeConnectionExtraContent | EpisodeConnectionCover | EpisodeConnectionPodcast | EpisodeConnectionEmbed | EpisodeConnectionEpisodeNumber | EpisodeConnectionSeason | EpisodeConnectionInputTag | EpisodeConnectionPublished_at | createEpisodePayload | updateEpisodePayload | deleteEpisodePayload | Home | updateHomePayload | deleteHomePayload | Pages | PagesConnection | PagesAggregator | PagesGroupBy | PagesConnectionId | PagesConnectionCreated_at | PagesConnectionUpdated_at | PagesConnectionTitle | PagesConnectionDescription | PagesConnectionSlug | PagesConnectionPublished_at | createPagePayload | updatePagePayload | deletePagePayload | Podcasts | PodcastsConnection | PodcastsAggregator | PodcastsGroupBy | PodcastsConnectionId | PodcastsConnectionCreated_at | PodcastsConnectionUpdated_at | PodcastsConnectionTitle | PodcastsConnectionSlug | PodcastsConnectionCover | PodcastsConnectionDescription | PodcastsConnectionSubtitle | PodcastsConnectionProducer | PodcastsConnectionPublished_at | createPodcastPayload | updatePodcastPayload | deletePodcastPayload | Posts | PostsConnection | PostsAggregator | PostsGroupBy | PostsConnectionId | PostsConnectionCreated_at | PostsConnectionUpdated_at | PostsConnectionCover | PostsConnectionTitle | PostsConnectionSlug | PostsConnectionSummary | PostsConnectionContent | PostsConnectionAuthor | PostsConnectionPublished_at | createPostPayload | updatePostPayload | deletePostPayload | Rodape | updateRodapePayload | deleteRodapePayload | Sobre | updateSobrePayload | deleteSobrePayload | Tags | TagsConnection | TagsAggregator | TagsGroupBy | TagsConnectionId | TagsConnectionCreated_at | TagsConnectionUpdated_at | TagsConnectionNome | TagsConnectionSlug | TagsConnectionPublished_at | createTagPayload | updateTagPayload | deleteTagPayload | Test | TestConnection | TestAggregator | TestGroupBy | TestConnectionId | TestConnectionCreated_at | TestConnectionUpdated_at | TestConnectionTitle | TestConnectionSlug | TestConnectionEmail | TestConnectionPublished_at | createTestPayload | updateTestPayload | deleteTestPayload | I18NLocale | UploadFile | UploadFileConnection | UploadFileAggregator | UploadFileAggregatorSum | UploadFileAggregatorAvg | UploadFileAggregatorMin | UploadFileAggregatorMax | UploadFileGroupBy | UploadFileConnectionId | UploadFileConnectionCreated_at | UploadFileConnectionUpdated_at | UploadFileConnectionName | UploadFileConnectionAlternativeText | UploadFileConnectionCaption | UploadFileConnectionWidth | UploadFileConnectionHeight | UploadFileConnectionFormats | UploadFileConnectionHash | UploadFileConnectionExt | UploadFileConnectionMime | UploadFileConnectionSize | UploadFileConnectionUrl | UploadFileConnectionPreviewUrl | UploadFileConnectionProvider | UploadFileConnectionProvider_metadata | deleteFilePayload | UsersPermissionsPermission | UsersPermissionsRole | UsersPermissionsRoleConnection | UsersPermissionsRoleAggregator | UsersPermissionsRoleGroupBy | UsersPermissionsRoleConnectionId | UsersPermissionsRoleConnectionName | UsersPermissionsRoleConnectionDescription | UsersPermissionsRoleConnectionType | createRolePayload | updateRolePayload | deleteRolePayload | UsersPermissionsUser | UsersPermissionsUserConnection | UsersPermissionsUserAggregator | UsersPermissionsUserGroupBy | UsersPermissionsUserConnectionId | UsersPermissionsUserConnectionCreated_at | UsersPermissionsUserConnectionUpdated_at | UsersPermissionsUserConnectionUsername | UsersPermissionsUserConnectionEmail | UsersPermissionsUserConnectionProvider | UsersPermissionsUserConnectionConfirmed | UsersPermissionsUserConnectionBlocked | UsersPermissionsUserConnectionRole | createUserPayload | updateUserPayload | deleteUserPayload | ComponentFragmentEmbed | ComponentFragmentHyperlink | ComponentFragmentIntegrante | ComponentFragmentLinks | ComponentFragmentListaDeLinks | ComponentFragmentSectionDivider | ComponentFragmentTags | ComponentSectionCallToAction | ComponentSectionExtra | ComponentSectionFeaturedPodcast | ComponentSectionSelectedEpisodes | ComponentSiteBarraLateral | ComponentSiteContato | ComponentSiteIntro

input InputID {
  id: ID!
}

enum PublicationState {
  LIVE
  PREVIEW
}

type AdminUser {
  id: ID!
  username: String
  firstname: String!
  lastname: String!
}

type Query {
  author(id: ID!, publicationState: PublicationState): Author
  authors(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Author!]!
  authorsConnection(sort: String, limit: Int, start: Int, where: JSON): AuthorConnection
  barraLateral(publicationState: PublicationState): BarraLateral
  category(id: ID!, publicationState: PublicationState): Category
  categories(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Category!]!
  categoriesConnection(sort: String, limit: Int, start: Int, where: JSON): CategoryConnection
  episode(id: ID!, publicationState: PublicationState): Episode
  episodes(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Episode!]!
  episodesConnection(sort: String, limit: Int, start: Int, where: JSON): EpisodeConnection
  home(publicationState: PublicationState): Home
  page(id: ID!, publicationState: PublicationState): Pages
  pages(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Pages!]!
  pagesConnection(sort: String, limit: Int, start: Int, where: JSON): PagesConnection
  podcast(id: ID!, publicationState: PublicationState): Podcasts
  podcasts(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Podcasts!]!
  podcastsConnection(sort: String, limit: Int, start: Int, where: JSON): PodcastsConnection
  post(id: ID!, publicationState: PublicationState): Posts
  posts(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Posts!]!
  postsConnection(sort: String, limit: Int, start: Int, where: JSON): PostsConnection
  rodape(publicationState: PublicationState): Rodape
  sobre(publicationState: PublicationState): Sobre
  tag(id: ID!, publicationState: PublicationState): Tags
  tags(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Tags!]!
  tagsConnection(sort: String, limit: Int, start: Int, where: JSON): TagsConnection
  test(id: ID!, publicationState: PublicationState): Test
  tests(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Test!]!
  testsConnection(sort: String, limit: Int, start: Int, where: JSON): TestConnection
  files(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UploadFile!]!
  filesConnection(sort: String, limit: Int, start: Int, where: JSON): UploadFileConnection
  role(id: ID!, publicationState: PublicationState): UsersPermissionsRole
  """Retrieve all the existing roles. You can't apply filters on this query."""
  roles(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UsersPermissionsRole!]!
  rolesConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsRoleConnection
  user(id: ID!, publicationState: PublicationState): UsersPermissionsUser
  users(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UsersPermissionsUser!]!
  usersConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsUserConnection
  me: UsersPermissionsMe
}

type Mutation {
  createAuthor(input: createAuthorInput): createAuthorPayload
  updateAuthor(input: updateAuthorInput): updateAuthorPayload
  deleteAuthor(input: deleteAuthorInput): deleteAuthorPayload
  updateBarraLateral(input: updateBarraLateralInput): updateBarraLateralPayload
  deleteBarraLateral: deleteBarraLateralPayload
  createCategory(input: createCategoryInput): createCategoryPayload
  updateCategory(input: updateCategoryInput): updateCategoryPayload
  deleteCategory(input: deleteCategoryInput): deleteCategoryPayload
  createEpisode(input: createEpisodeInput): createEpisodePayload
  updateEpisode(input: updateEpisodeInput): updateEpisodePayload
  deleteEpisode(input: deleteEpisodeInput): deleteEpisodePayload
  updateHome(input: updateHomeInput): updateHomePayload
  deleteHome: deleteHomePayload
  createPage(input: createPageInput): createPagePayload
  updatePage(input: updatePageInput): updatePagePayload
  deletePage(input: deletePageInput): deletePagePayload
  createPodcast(input: createPodcastInput): createPodcastPayload
  updatePodcast(input: updatePodcastInput): updatePodcastPayload
  deletePodcast(input: deletePodcastInput): deletePodcastPayload
  createPost(input: createPostInput): createPostPayload
  updatePost(input: updatePostInput): updatePostPayload
  deletePost(input: deletePostInput): deletePostPayload
  updateRodape(input: updateRodapeInput): updateRodapePayload
  deleteRodape: deleteRodapePayload
  updateSobre(input: updateSobreInput): updateSobrePayload
  deleteSobre: deleteSobrePayload
  createTag(input: createTagInput): createTagPayload
  updateTag(input: updateTagInput): updateTagPayload
  deleteTag(input: deleteTagInput): deleteTagPayload
  createTest(input: createTestInput): createTestPayload
  updateTest(input: updateTestInput): updateTestPayload
  deleteTest(input: deleteTestInput): deleteTestPayload
  """Delete one file"""
  deleteFile(input: deleteFileInput): deleteFilePayload
  """Create a new role"""
  createRole(input: createRoleInput): createRolePayload
  """Update an existing role"""
  updateRole(input: updateRoleInput): updateRolePayload
  """Delete an existing role"""
  deleteRole(input: deleteRoleInput): deleteRolePayload
  """Create a new user"""
  createUser(input: createUserInput): createUserPayload
  """Update an existing user"""
  updateUser(input: updateUserInput): updateUserPayload
  """Delete an existing user"""
  deleteUser(input: deleteUserInput): deleteUserPayload
  upload(refId: ID, ref: String, field: String, source: String, info: FileInfoInput, file: Upload!): UploadFile!
  multipleUpload(refId: ID, ref: String, field: String, source: String, files: [Upload]!): [UploadFile]!
  updateFileInfo(id: ID!, info: FileInfoInput!): UploadFile!
  login(input: UsersPermissionsLoginInput!): UsersPermissionsLoginPayload!
  register(input: UsersPermissionsRegisterInput!): UsersPermissionsLoginPayload!
  forgotPassword(email: String!): UserPermissionsPasswordPayload
  resetPassword(password: String!, passwordConfirmation: String!, code: String!): UsersPermissionsLoginPayload
  emailConfirmation(confirmation: String!): UsersPermissionsLoginPayload
}

"""The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."""
scalar JSON

"""A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."""
scalar DateTime

"""A time string with format: HH:mm:ss.SSS"""
scalar Time

"""A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."""
scalar Date

"""The `Long` scalar type represents 52-bit integers"""
scalar Long

"""The `Upload` scalar type represents a file upload."""
scalar Upload
